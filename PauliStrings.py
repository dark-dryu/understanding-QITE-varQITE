# %%
from itertools import product
import numpy as np
import scipy.sparse as sp
from qiskit.quantum_info import Pauli



# %%
def general(H_trot,D,n_qubits,sparse=True):
    """
    This function generates the 4^D Pauli strings needed to compute
    the unitary evolution of the ITE step generated by a Hamiltonian 
    piece which is T-local
    """
    num_paulis=int(4**D)
    print("The number of Paulis is ",num_paulis)
    PD = [[0 for i in range(num_paulis)] for j in range(H_trot.Nk)]
    fail=False
    if H_trot.T>D:
        print("Your domain (D=",D,") is to small for your Trotterization (T=",H_trot.T,')')
        fail=True
    else:
        #displacement of initial qubit in which we compute expectation of Pauli string (if T=D no displacement, if D>T odd: centered with gravity towards right, if D>T even: centered)
        disp=np.floor((D-H_trot.T)/2).astype(int)
        for j in range(H_trot.Nk):
            i=0
            for qi in product('IXYZ',repeat=D):
                s=["I"]*n_qubits
                for k in range(D):
                    ind=(H_trot.indk[j]+k-disp)%n_qubits
                    s[ind]=qi[k]
                pstr=''.join(s)
                PD[j][i]=sp.csc_matrix(Pauli(pstr).to_matrix(sparse=sparse))
                i=i+1
    if sparse:
        PD = [[sp.csc_matrix(val) for val in row] for row in PD]
    return num_paulis,PD,fail

# %%
def real(H_trot,D,n_qubits,sparse=True):
    """
    This function generates the 2^D*(2^D-1)/2 Pauli strings needed to compute
    the unitary evolution of the ITE step generated by a Hamiltonian
    piece which is T-local. This function assumes that the Hamiltonian is 
    real and that the initial state (and all subsequent states) are REAL.
    """
    num_paulis=int((2**D)*(2**D-1)/2)
    print("The number of Paulis is ",num_paulis)
    PD = [[0 for i in range(num_paulis)] for j in range(H_trot.Nk)]
    fail=False
    if H_trot.T>D:
        print("Your domain (D=",D,") is to small for your Trotterization (T=",H_trot.T,')')
        fail=True
    else:
        #displacement of initial qubit in which we compute expectation of Pauli string (if T=D no displacement, if D>T odd centered with gravity towards right, if D>T even centered)
        disp=np.floor((D-H_trot.T)/2).astype(int)
        for j in range(H_trot.Nk):
            i=0
            for qi in product('IXYZ',repeat=D):
                s=["I"]*n_qubits
                for k in range(D):
                    ind=(H_trot.indk[j]+k-disp)%n_qubits
                    s[ind]=qi[k]
                plist=s
                num_Y=0
                for x in plist:
                    if x=="Y":
                        num_Y+=1
                if (num_Y % 2) != 0:
                    pstr=''.join(plist)
                    PD[j][i]=Pauli(pstr).to_matrix(sparse=sparse)
                    i=i+1
    if sparse:
        PD = [[sp.csc_matrix(val) for val in row] for row in PD]
    return num_paulis,PD,fail
